# tools.py
import pandas as pd
import traceback
from source_code.state import AgentState

def code_executor_agent(state: AgentState) -> dict:
    """
    The Executor: Takes the Python code generated by the AI,
    loads the dataset, runs the code, and saves the output.
    """
    print("\n" + "="*60)
    print("[Executor] Running Generated Python Code")
    print("="*60)

    file_path = state["file_path"]
    cleaning_code = state.get("cleaning_code", "")

    if not cleaning_code:
        print("[Executor] No code found to execute.")
        return {"error_log": "No cleaning code provided by the agent."}

    try:
        # 1. Load your actual data into memory
        print(f"[Executor] Loading {file_path}...")
        df = pd.read_csv(file_path)

        # 2. Set up the environment for the code to run in
        # We pass 'df' and 'pd' so the AI's code knows what they are
        local_vars = {"df": df, "pd": pd}

        # 3. Execute the AI's code
        print("[Executor] Applying standardizations...")
        exec(cleaning_code, {}, local_vars)

        # 4. Extract the newly modified dataframe
        df_clean = local_vars["df"]

        # 5. Save the result to prove it worked!
        output_path = "standardized_output.csv"
        df_clean.to_csv(output_path, index=False)
        
        print(f"[Executor] ✅ Success! Clean dataset saved to: {output_path}")
        
        # Return a clear error log since it succeeded
        return {"error_log": None}

    except Exception as e:
        # If the AI wrote bad code, we catch the exact error message!
        error_msg = f"{type(e).__name__}: {str(e)}\n{traceback.format_exc()}"
        print(f"[Executor] ❌ ERROR ENCOUNTERED:\n{error_msg}")
        
        # We save the error to the state so the AI can fix it in the next loop
        return {"error_log": error_msg}